    inicia na cidade X
    path[0] = X
    pathCount++

se (ciclo hamiltoniano passando X) for 0
    inicia pilha
    instancia de count pra verificar adjacencia
    loop pra cada cidade adjacente
        se maior que 0                // && não visitou ainda (verificar path até agora ou pilha)
            se igual cidade inicial (path[0] ou algo assim)
                se passou por todos
                    path[pathCount++] = i
                    return 1
            count++
            push cidade
                                      // hamilton nele
    se count for 1
        nem verifica, 
        só popa em w
        e lasca o hamiltão nele
        se resposta do hamiltão for 1
            adiciona w no path
            return 1
        senão
            return 0
    senão
        enquanto pilha não vazia
            w = pop
            se não visitou
                s = hamilton
                se( s == 1 )
                    adiciona w no path
                    return 1
                else if ( s == -1)

        return 0
  printa path
senão
  printa "não foi possivel ciclar"